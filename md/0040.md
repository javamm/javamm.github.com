# 层次遍历二叉树
## 题目：写一个函数，层次遍历二叉树
## 参考答案
```Java
/**
* 思路：每打印一个结点的时候，如果该结点有子结点，将子结点放入队列末尾
*/
```

# 字符串的排列
## 题目：输入一个字符串，打印出该字符串中字符的所有排列。如输入abc,则输出acb,bac,bca,cab,cba
## 参考答案
```Java
/**
* 将字符串分为两部分，一部分是字符串的第一个字符,另一部分是第一个字符外所有字符
* 用递归 
*/
```

# 字符串的所有组合
## 题目：输入一个字符串，打印出该字符串中字符的所有组合。如输入abc,则输出a,b,c,ab,ac,bc,abc,注，ab,ba是不同的排列，但只算一个组合
```Java
/**
* 输入n个字符，则能构成长度为1,2,...n的组合
* 求n个字符长度为m的组合的时候，把m个字符分为两部分，第一个和m-1个，递归
*/
```
# 正方体所有面之和相等
## 输入一个含有8个数字的数组，判断有没有可能这8个数字分别放到正方体的8个顶点上，使得每一面的顶点之和都相等。
```Java
/**
* 如输入a1,a2,a3,a4,a5,a6,a7,a8,求所有排列，看是否满足条件，a1+a2+a3+a4==a5+a6+a7+a8,a1+a3+a5+a7=a2+a4+a6+a8,并且a1+a2+a5+a6=a3+a4+a7+a8
*/
``` 
# 0029 数组中出现次数超过一半的数字
## 题目：数组中有一个数字出现的次数超过了数组长度的一半，请求出这个数字。如{1,2,3,2,2,2,5,4,2},此数字为2
```Java
/**
* 思路一：排序，排好序后，求中间数字
* 根据快排思想，先随机选一个数字，使比他小的都排在左边，比他大的都排右边。完成后，若此数字下标为n/2,即为此数。如果下标> n/2,那么此数位于左边,可在左半部查找，用递归。否则位于右边
* 思路二：
* 遍历数组时，保存两个值，一个为数组中数字，一个为次数
* 当遍历下一个数字时，若与保存数字相同，次数+1.若与保存数字不同，次数-1,若次数=0，重新保存新数字，并将次数设为1.最后一次把次数设为1的数字即为所需的数字
* eg: 
* 1,1
* 2,1
* 3,1
* 2,1
* 2,2
* 2,3
* 2,2
* 2,1
* 2,2
*/
```
# 0030 求一个数组的第k小的数
## 题目：给定一个无序整数数组，返回这个数组中第k小的数 
```Java
/**
* 思路一：
* 最平常的思路是将数组排序，最快的排序是快排，然后返回已排序数组的第k个数，算法时间复杂度为O（nlogn），空间复杂度为O（1）。使用快排的思想，但是每次只对patition之后的数组的一半递归，这样可以将时间复杂度将为O（n）。

* 具体的思路：将数组按照第一个数字first进行划分，将比first小的放在左边，比first大的放在右边，first放中间。返回patition之后first的下标j。如果此时j+1==k（+1是因为数组下标从0开始）那么说明a[j]就是要找的第k个数。如果j+1<k,递归查找左半部分；如果j+1>k，递归查找右半部分
* 
* 思路二：
* 维持一个大小为k的大顶堆，遍历一次数组，如果数组中的元素比堆顶的元素小，那么就更新堆。最后堆中存放的是数组中的前k小元素。堆顶元素即为要求的第k小个数。

* 这种算法不需要改变原数组结构，但是需要额外维持一个大小为O（k）的堆，时间复杂度为（nlogk）。当k比n小的多的时候，这个算法也是一个很好的选择
/*
```
# 0031 连续子数组的最大和
## 题目：输入一个整数型数组，数组中有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值
```Java
/**
* 思路一：列举数组规律
*   维护一个最大值max
*   若max < 0 ,抛弃
*   若 > max ,更新max
*
* 思路二：动态规划
*   f(i)表示以第i个数字结尾的子数组的最大和,0<=i<n,有如下公式
*     f(i) = data[i], i=0或f(i-1)<=0
*     f(i) = f(i-1) + data[i] i!=0 && f(i-1) > 0
*/
```
# 0032 从1到n整数中1出现的次数
## 题目：输入一个整数n,求从1到n这n个整数的十进制表示中1出现的次数。eg: 输入12,包含1的数字，1,10,11,12,共出现了5次

# 0033 把数组排成最小的数
## 题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。eg输入数组{3,32,321} ,则打印这3个数字排成的最小数字321323
## 参考答案
```Java
/**
* 思路一：求所有数字的全排列，然后比较大小
*/
```

# 0034 丑数
## 题目：我们把只包含因子2，3，5的数称为丑数(ugly number),求按从小到大的顺序的第1500个丑数。eg: 6,8都为丑数，而14不是，因为14含有因子7
## 参考答案
```Java
```
# 0035 第一个只出现一次的字符
## 题目：在字符串中找出第一个只出现一次的字符。eg: 输入“abaccdeff“，输出b
## 参考答案
```Java
/**
* 根据ASCII码值作为数组下标，构造字符Hash
*/
```

# 删除字符串
## 题目：定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。eg: "We are students","aeiou",结果为"W r studnts"
## 参考答案
```Java
/**
* 构造字符Hash,O（1）时间即可判断是不是在第一个字符串中出现过
*/
```

# 删除字符串所有重复内容
## 题目：定义一个函数，删除字符串中所有重复出现的字符。如输入google,输出为gole
## 参考答案
```Java
/**
* boolean型的字符hash,当扫描到g时，将g的ascii码103下标的标为true,下次再扫描到g时，即知重复
*/
```

# 变位词
## 题目: 在英语中，如果两个单词中出现的字母相同，并且每个字母出现的次数也相同，那么这两个单词互为变位词(Anagram),如silent与listen,evil与live, 请完成一个函数，判断输入的两个字符串是不是互为变位词
## 参考答案
```Java
/**
* 字符hash,扫描第一个字符串，每扫描到一个字符串，对应的值加1，然后再扫描第二个字符串，对应的值-1,最后若hash中的所有的值都为0,那么互为变位词
*/
```

# 数组中的逆序对
## 题目：在数组中的两个数字，如果前面一个数字 > 后面一个数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中逆序对的总数。eg: {7,5,6,4},有5个逆序对，{7,6},{7,5},{7,4},{6,4},{5,4}

# 两个链表的第一个公共结点
## 题目：输入两个链表，找出它们的第一个公共结点。
## 参考答案
```Java
/**
* 链表如果有公共结点，肯定为Y字型，而非X型
* 从后往前比较
* 将链表放入栈中
*/
```

# 数字在排序数组中出现的次数
## 题目：统计一个数字在排序数组中出现的次数。如输入{1,2,3,3,3,3,4,5}，输入3,则输出为4
```Java
/**
* 二分查找，找出3的起始位置和结束位置,时间复杂度为O(logn)
*/
```

# 二叉树的深度
## 题目：输入一颗二叉树的根结点，求该树的深度
## 参考答案
```Java
/**
* 树只有一个结点，深度为1
* 若只有左子树，深度为左子树深度 + 1
* 若只有右子树，深度为右子树深度 + 1
* 既有左子树，又有右子树，深度为左子树和右子树中的较大值 + 1
*/
int treeDepth(BinaryTreeNode binaryTreeNode) {
	if(binaryTreeNode == null ) {
		return 0;
	}

	int leftDepth=treeDepth(binaryTreeNode.left);
	int rightDepth=treeDepth(binaryTreeNode.right);
	return (leftDepth > rightDepth) ? (leftDepth+1):(rightDepth+1);
}
```

# 平衡二叉树
## 题目：输入一颗二叉树的根结点，判断该树是不是平衡二叉树.如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一颗平衡二叉树
## 参考答案
```Java
/**
* 后序遍历
* 递归求出左子树，右子树深度
* 对深度进行比较
*/
```

# 数组中只出现一次的数字
## 题目；一个整数数组中除了两个数字外，其它数字都出现了两次，请找出这两个只出现了一次的数字。要求时间复杂度是O(n),空间复杂度是O(1)
## 参考答案
```Java
/**
* 任何一个数字异或它自己都等于０
* eg: {2,4,3,6,3,2,5,5}，异或得到的结果为0010，把数组拆分，按照倒数第二位是不是1，会拆分为{2,3,6,3,2}和{4,5,5}，再求异或即可得到结果
*/
```

# 和为s的两个数组
## 题目：输入一个递增排序的数组和一个数字s,在数组中查找两个数，使它们的和正好为s。如果有多对数字的和等于s，输出任意一对即可。eg：输入{1,2,4,7,11,15}和15，输出为{4,11}
```Java
/**
* 定义两个指针，headPoint,tailPoint
* 若data[headPoint] + data[tailPoint] > 15 ,tailPoint --
* 若data[headPoint] + data[tailPoint] < 15 ,headPoint ++
**/
```

# 和为s的连续正数序列
## 题目：输入一个正数s，打印出所有和为s的连续正数序列（至少包含两个数)。如输入15，则输出为{1,2,3,4,5}，{4,5,6},{7,8}
```Java
/**
* 定义两个指针，firstPoint=0,secondPoint=1
* 若data[firstPoint} +...+ data[secondPoint] < 15 secondPoint ++; 
* 若data[firstPoint} +...+ data[secondPoint] > 15 firstPoint ++; 
* 以输入9为例：
* 1 + 2 < 9 
* 1 + 2 + 3 <9
* 1 + 2 + 3 + 4 > 9
* 2 + 3 + 4 = 9
* 2 + 3 + 4 + 5 > 9
* 3 + 4 + 5 >9
* 4 + 5 = 9
**/
```

# 翻转单词顺序
## 输入一个英文句子，翻转句子中单词的顺序，但单词内的顺序不变，标点符号和字母一样处理。eg: "I am a student." 输出为"student. a am I"
```Java
/**
* 1. 翻转所有字符，得到".tneduts a ma I"
* 2. 翻转每个单词中字符的顺序
**/
```

# 左旋转字符串
## 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。实现一个函数实现字符串左旋转操作的功能。eg 输入"abcdefg"和2，则结果为"cdefgab"
```Java
/**
* 先翻转成 ba + gfedc
* 再翻转bagfedc，即得cdefgab
*/
```

# n个骰子的点数
## 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，输出s的概率
```Java
/**
* 总数为6的n次方
* 解法一：递归 f(1) 有6种可能 f(n) = s - f(n-1)
**/
```

# 扑克牌的顺子
## 从扑克牌中随机抽5张牌，判断是不是一个顺子。A为1,J为11,Q为12,K为13。大小王可看成任意数字
/**
* 将大小王看成数字0
* 排序
* 统计0的个数以及相邻数字间空缺总数
* 重复出现，数组不是连续的

# 圆圈中最后剩下的数字
## 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字，求这个圆圈里剩下的最后一个数字
/**
* 约瑟夫环
* 解法一：环形链表 时间复杂度O(mn)
* 解法二：f(n,m) = 0 (n = 1) f(n,m)=[f(n-1,m) + m] % n (n>1)
*/

# 求1+2+...+n
## 求1+2+...+n,要求不能使用乘除法，for,while,if,else,switch,case,a?b:c

# 不用加减乘除做加法
## 写一个函数，求两个整数之和，要求在函数体内不得使用+ - * /
/**
* 1. 各位相加不进位，异或
* 2. 考虑进位，与运算
* 3. 将前面两个数相加,即重复1,2,直到不产生进位为止
*/

# 输入两颗树结点，求它们的最低公共祖先

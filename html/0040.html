<!Doctype html><html xmlns=http://www.w3.org/1999/xhtml><head><meta http-equiv=Content-Type content="text/html;charset=utf-8">
<h1 id="层次遍历二叉树">层次遍历二叉树</h1>
<h2 id="题目写一个函数层次遍历二叉树">题目：写一个函数，层次遍历二叉树</h2>
<h2 id="参考答案">参考答案</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
*<span class="co"> 思路</span>：<span class="co">每打印一个结点的时候</span>，<span class="co">如果该结点有子结点</span>，<span class="co">将子结点放入队列末尾</span>
<span class="co">*/</span></code></pre>
<h1 id="字符串的排列">字符串的排列</h1>
<h2 id="题目输入一个字符串打印出该字符串中字符的所有排列如输入abc则输出acbbacbcacabcba">题目：输入一个字符串，打印出该字符串中字符的所有排列。如输入abc,则输出acb,bac,bca,cab,cba</h2>
<h2 id="参考答案-1">参考答案</h2>
<p><code>Java /** * 将字符串分为两部分，一部分是字符串的第一个字符,另一部分是第一个字符外所有字符 * 用递归  */</code> # 字符串的所有组合 ## 题目：输入一个字符串，打印出该字符串中字符的所有组合。如输入abc,则输出a,b,c,ab,ac,bc,abc,注，ab,ba是不同的排列，但只算一个组合 <code>Java /** * 输入n个字符，则能构成长度为1,2,...n的组合 * 求n个字符长度为m的组合的时候，把m个字符分为两部分，第一个和m-1个，递归 */</code> # 正方体所有面之和相等 ## 输入一个含有8个数字的数组，判断有没有可能这8个数字分别放到正方体的8个顶点上，使得每一面的顶点之和都相等。 <code>Java /** * 如输入a1,a2,a3,a4,a5,a6,a7,a8,求所有排列，看是否满足条件，a1+a2+a3+a4==a5+a6+a7+a8,a1+a3+a5+a7=a2+a4+a6+a8,并且a1+a2+a5+a6=a3+a4+a7+a8 */</code> # 0029 数组中出现次数超过一半的数字 ## 题目：数组中有一个数字出现的次数超过了数组长度的一半，请求出这个数字。如{1,2,3,2,2,2,5,4,2},此数字为2 <code>Java /** * 思路一：排序，排好序后，求中间数字 * 根据快排思想，先随机选一个数字，使比他小的都排在左边，比他大的都排右边。完成后，若此数字下标为n/2,即为此数。如果下标&gt; n/2,那么此数位于左边,可在左半部查找，用递归。否则位于右边 * 思路二： * 遍历数组时，保存两个值，一个为数组中数字，一个为次数 * 当遍历下一个数字时，若与保存数字相同，次数+1.若与保存数字不同，次数-1,若次数=0，重新保存新数字，并将次数设为1.最后一次把次数设为1的数字即为所需的数字 * eg:  * 1,1 * 2,1 * 3,1 * 2,1 * 2,2 * 2,3 * 2,2 * 2,1 * 2,2 */</code> # 0030 求一个数组的第k小的数 ## 题目：给定一个无序整数数组，返回这个数组中第k小的数 ```Java /<em>*</em> 思路一： * 最平常的思路是将数组排序，最快的排序是快排，然后返回已排序数组的第k个数，算法时间复杂度为O（nlogn），空间复杂度为O（1）。使用快排的思想，但是每次只对patition之后的数组的一半递归，这样可以将时间复杂度将为O（n）。</p>
<ul>
<li>具体的思路：将数组按照第一个数字first进行划分，将比first小的放在左边，比first大的放在右边，first放中间。返回patition之后first的下标j。如果此时j+1==k（+1是因为数组下标从0开始）那么说明a[j]就是要找的第k个数。如果j+1<k,递归查找左半部分；如果j+1>k，递归查找右半部分</li>
</ul>
<p>* * 思路二： * 维持一个大小为k的大顶堆，遍历一次数组，如果数组中的元素比堆顶的元素小，那么就更新堆。最后堆中存放的是数组中的前k小元素。堆顶元素即为要求的第k小个数。</p>
<ul>
<li>这种算法不需要改变原数组结构，但是需要额外维持一个大小为O（k）的堆，时间复杂度为（nlogk）。当k比n小的多的时候，这个算法也是一个很好的选择 /* <code># 0031 连续子数组的最大和 ## 题目：输入一个整数型数组，数组中有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值</code>Java /**</li>
<li>思路一：列举数组规律</li>
<li>维护一个最大值max</li>
<li>若max &lt; 0 ,抛弃</li>
<li>若 &gt; max ,更新max *</li>
<li>思路二：动态规划</li>
<li>f(i)表示以第i个数字结尾的子数组的最大和,0&lt;=i&lt;n,有如下公式</li>
<li>f(i) = data[i], i=0或f(i-1)&lt;=0</li>
<li>f(i) = f(i-1) + data[i] i!=0 &amp;&amp; f(i-1) &gt; 0 */ ``` # 0032 从1到n整数中1出现的次数 ## 题目：输入一个整数n,求从1到n这n个整数的十进制表示中1出现的次数。eg: 输入12,包含1的数字，1,10,11,12,共出现了5次</li>
</ul>
<h1 id="把数组排成最小的数">0033 把数组排成最小的数</h1>
<h2 id="题目输入一个正整数数组把数组里所有数字拼接起来排成一个数打印能拼接出的所有数字中最小的一个eg输入数组332321-则打印这3个数字排成的最小数字321323">题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。eg输入数组{3,32,321} ,则打印这3个数字排成的最小数字321323</h2>

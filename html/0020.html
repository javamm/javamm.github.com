<!Doctype html><html xmlns=http://www.w3.org/1999/xhtml><head><meta http-equiv=Content-Type content="text/html;charset=utf-8">
<h1 id="调整数组顺序使奇数位于偶数前面">0011 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="题目输入一个整数数组实现一个函数来调整该数组中数字的顺序使得所有奇数位于数组的前半部分所有偶数位于数组的后半部分">题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分</h2>
<h2 id="参考答案">参考答案</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
<span class="dv">1</span><span class="co">. 维护两个指针</span>，<span class="co">P1指向数组的第一个数字</span>，<span class="co">向后移动</span>;<span class="co"> P2指向数组的最后一个数字</span>，<span class="co">向前移动</span>。
<span class="dv">2</span>.<span class="co"> 在指针相遇前</span>，<span class="co">若P1指向数字是偶数</span>，<span class="co">P2指向数字是奇数</span>，<span class="co">则交换这两个数字</span>
<span class="dv">3</span>.<span class="co"> 把比较的逻辑部分抽取出来</span>，<span class="co">实现解耦</span>，<span class="co">以满足更多的比较</span>，<span class="co">如把所有的负数放在非负数前面</span>，<span class="co">能被3整除的数放在不能被3整除的数前面</span>
<span class="dv">4</span>.<span class="co"> 代码扩展性</span>，<span class="co">可重用性</span>
<span class="co">*/</span></code></pre>
<h1 id="链表中倒数第k个结点">0012 链表中倒数第K个结点</h1>
<h2 id="题目输入一个单向链表输出该链表中倒数第k个结点">题目：输入一个单向链表，输出该链表中倒数第k个结点</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
<span class="dv">1</span><span class="co">. 两个指针P1</span>,<span class="co">P2</span>
<span class="dv">2</span>.<span class="co"> P1从链表头向前遍历走k</span><span class="dv">-1</span>,<span class="co">P2不变</span>
<span class="dv">3</span>.<span class="co"> 第k步</span>，<span class="co">P1</span>,<span class="co">P2一起移动</span>，<span class="co">当P1到达尾结点时</span>，<span class="co">P2正好是倒数第k个结点</span>
<span class="co">*/</span></code></pre>
<h1 id="求链表的中间结点">0013 求链表的中间结点</h1>
<h2 id="题目如果链表中结点总数为奇数返回中间结点如果结点总数是偶数返回中间两个结点的任意一个">题目：如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
<span class="dv">1</span><span class="co">. 类同0012</span>，<span class="co">定义两个指针P1</span>,<span class="co">P2</span>
<span class="dv">2</span>.<span class="co"> 遍历链表</span>，<span class="co">P1走一步</span>，<span class="co">P2走两步</span>，<span class="co">当P2至达末尾时</span>，<span class="co">P1正好在链表的中间</span>
<span class="co">*/</span></code></pre>
<h1 id="判断一个单向链表是形成了环形结构">0014 判断一个单向链表是形成了环形结构</h1>
<h2 id="题目-判断一个单向链表是形成了环形结构">题目： 判断一个单向链表是形成了环形结构</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="dv">1</span>. 类同<span class="dv">0013</span>,定义两个指针P1,P2
<span class="dv">2</span>. <span class="fu">遍</span>历链表，P1走一步，P2走两步，如果走的快的追上了走的慢的，则为环形链表
<span class="dv">3</span>. 如果<span class="fu">P2走到</span>了链表末尾，仍没有追上P1,则不是环形链表</code></pre>
<h1 id="反转链表">0015 反转链表</h1>
<h2 id="题目定义一个函数输入一个链表的头结点反转该链表并输出反转后链表的头结点">题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
*<span class="co"> 为防止链表断开</span>，<span class="co">需要保存结点</span>
<span class="co">*/</span></code></pre>
<h1 id="合并两个排序的链表">0016 合并两个排序的链表</h1>
<h2 id="题目输入两个递增排序的链表合并这两个链表并使新链表中的结点仍然是按照递增排序的">题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的</h2>
<pre class="sourceCode Java"><code class="sourceCode java"></code></pre>
<h1 id="树的子结构">0017 树的子结构</h1>
<h2 id="题目输入一棵二叉树a和b判断b是不是a的子结构">题目：输入一棵二叉树A和B,判断B是不是A的子结构。</h2>
<h1 id="二叉树的镜像">0018 二叉树的镜像</h1>
<h2 id="题目请完成一个函数输入一个二叉树输出它的镜像">题目：请完成一个函数，输入一个二叉树，输出它的镜像</h2>
<p>```Java /<em>*</em> 前序遍历树的每个结点 * 如果遍历到的结点有子结点，则交换子结点 * 当交换完所有非叶子结点的左右子结点后，就得到了树的镜像 */ public void mirrorRecursively(BinaryTreeNode binaryTreeNode) { if(binaryTreeNode==null || (binaryTreeNode.leftNode==null &amp;&amp; binaryTreeNode.rightNode==null) ) { return; }</p>
<pre><code>BinaryTreeNode tempNode=binaryTreeNode.leftNode;
binaryTreeNode.leftNode=binaryTreeNode.rightNode;
binaryTreeNode.rightNode=tempNode;

// 递归
mirrorRecursively(binaryTreeNode.leftNode);
mirrorRecursively(binaryTreeNode.rightNode);        </code></pre>
<p>} <code># 0019 包含min函数的栈 ## 题目：定义栈的数据结构，实现一个得到栈最小值的min函数。使得调用min,push及pop的时间复杂度都为O(1). ## 参考答案</code>Java /<em>*</em> 采用辅助栈，将最小值压入辅助栈中 */ ```</p>
<h1 id="栈的压入弹出序列">0020 栈的压入，弹出序列</h1>
<h2 id="题目输入两个整数序列第一个序列表示栈的压入顺序请判断第二个序列是否为该栈的弹出顺序假设压入栈的所有数字都不相等如序列12345为压栈序列序列45321为该压栈序列对应的一个弹出序列但43512不是该压栈序列的弹出序列">题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字都不相等。如序列1,2,3,4,5为压栈序列，序列4,5,3,2,1为该压栈序列对应的一个弹出序列，但4,3,5,1,2不是该压栈序列的弹出序列</h2>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="co">/**</span>
*<span class="co"> 如果下一个弹出的数字刚好是栈顶数字</span>，<span class="co">直接弹出</span>
*<span class="co"> 如果下一个弹出的数字不在栈顶</span>，<span class="co">把压栈序列中还没有入栈的数字压入辅助栈</span>，<span class="co">直到把下一个需要弹出的数字压入栈顶为止</span>
*<span class="co"> 如果所有的数字都压入栈了</span>，<span class="co">仍然没有找到下一下弹出的数字</span>，<span class="co">那么该序列不可能是一个弹出序列</span>
<span class="co">*/</span></code></pre>
